import { Controller } from "@hotwired/stimulus"

export default class extends Controller {
  static targets = ["referenceTag", "input", "suggestions", "errorMessages"];

  connect() {
    this.selectedSuggestionIndex = -1;
    this.suggestions = [];
    if (this.hasInputTarget) {
      const addButton = this.inputTarget.parentNode.querySelector('button[type="button"]');
      if (addButton) {
        addButton.addEventListener('click', (e) => {
          e.preventDefault();
          const value = this.inputTarget.value.trim();
          if (value) {
            this.addReferenceByTitle(value);
          }
        });
      }
    }
  }

  autocomplete(event) {
    const query = this.inputTarget.value.trim();
    if (query.length < 2) {
      this.suggestionsTarget.classList.add("hidden");
      this.suggestionsTarget.innerHTML = "";
      return;
    }
    fetch(`/bibliographic_references.json?query=${encodeURIComponent(query)}`)
      .then(r => r.json())
      .then(data => {
        this.suggestions = data;
        if (data.length === 0) {
          this.suggestionsTarget.classList.add("hidden");
          this.suggestionsTarget.innerHTML = "";
          return;
        }
        this.suggestionsTarget.innerHTML = data.map((ref, i) =>
          `<li class='px-2 py-1 cursor-pointer hover:bg-green-100 flex items-center justify-between' data-index='${i}'>
            <span>${ref.title}</span>
            <button type='button' class='ml-2 bg-green-500 text-white px-2 py-1 rounded add-ref-btn' data-index='${i}'>Adicionar</button>
          </li>`
        ).join("");
        this.suggestionsTarget.classList.remove("hidden");
        this.selectedSuggestionIndex = -1;
        // Adiciona event listener para clique nas sugestões e botões
        this.suggestionsTarget.querySelectorAll('li').forEach(li => {
          li.addEventListener('click', (e) => {
            // Só executa se não for o botão
            if (!e.target.classList.contains('add-ref-btn')) {
              const idx = parseInt(li.getAttribute('data-index'));
              this.addReferenceFromSuggestion(idx);
              this.inputTarget.value = "";
              this.suggestionsTarget.classList.add("hidden");
              this.suggestionsTarget.innerHTML = "";
            }
          });
          // Botão de adicionar
          const btn = li.querySelector('.add-ref-btn');
          if (btn) {
            btn.addEventListener('click', (e) => {
              e.stopPropagation();
              const idx = parseInt(btn.getAttribute('data-index'));
              this.addReferenceFromSuggestion(idx);
              this.inputTarget.value = "";
              this.suggestionsTarget.classList.add("hidden");
              this.suggestionsTarget.innerHTML = "";
            });
          }
        });
      });
  }

  handleKeydown(event) {
    if (event.key === "Enter") {
      event.preventDefault();
      if (this.suggestions && this.suggestions.length > 0 && this.selectedSuggestionIndex >= 0) {
        this.addReferenceFromSuggestion(this.selectedSuggestionIndex);
      } else if (this.inputTarget.value.trim() !== "") {
        this.addReferenceByTitle(this.inputTarget.value.trim());
      }
    } else if (this.suggestions && this.suggestions.length > 0) {
      if (event.key === "ArrowDown") {
        event.preventDefault();
        this.selectedSuggestionIndex = Math.min(this.selectedSuggestionIndex + 1, this.suggestions.length - 1);
        this.updateSuggestionHighlight();
      } else if (event.key === "ArrowUp") {
        event.preventDefault();
        this.selectedSuggestionIndex = Math.max(this.selectedSuggestionIndex - 1, 0);
        this.updateSuggestionHighlight();
      }
    }
  }

  updateSuggestionHighlight() {
    this.suggestionsTarget.querySelectorAll('li').forEach((li, i) => {
      if (i === this.selectedSuggestionIndex) {
        li.classList.add('bg-green-100');
      } else {
        li.classList.remove('bg-green-100');
      }
    });
  }

  addReferenceFromSuggestion(index) {
    const ref = this.suggestions[index];
    this.addReference(ref);
    this.inputTarget.value = "";
  }

  addReferenceByTitle(title) {
    fetch(`/bibliographic_references.json?query=${encodeURIComponent(title)}`)
      .then(r => r.json())
      .then(data => {
        if (data.length > 0) {
          // Encontrou pelo menos uma referência com esse título, vamos usar a primeira
          this.addReference(data[0]);
        } else {
          alert("Referência não encontrada.");
        }
      })
      .catch(() => alert("Erro ao buscar referência."));
  }

  addReference(ref) {
    const container = this.element.querySelector('.flex.flex-wrap.gap-2.mb-2');
    if (!container) return;

    // Verifica se a referência já foi adicionada
    const existingRef = container.querySelector(`[data-bibliographic-references-index="${ref.id}"]`);
    if (existingRef) {
      alert("Esta referência já foi adicionada ao artigo.");
      return;
    }

    // Cria o elemento da referência
    const refTag = document.createElement('span');
    refTag.className = 'flex bg-stone-100 text-black px-2 py-2 rounded items-center w-full';
    refTag.setAttribute('data-bibliographic-references-target', 'referenceTag');
    refTag.setAttribute('data-bibliographic-references-index', ref.id);
    refTag.innerHTML = `
      ${ref.title} (${ref.year || "Sem ano"}) 
      <button
        type="button"
        class="ml-2 text-red-500 hover:text-red-700 font-bold cursor-pointer self-end"
        data-action="click->bibliographic-references#removeReference"
        data-bibliographic-references-index="${ref.id}"
      >
        &times;
      </button>
      <input type="hidden" name="article[bibliographic_reference_ids][]" value="${ref.id}" />
    `;

    // Adiciona ao container
    container.appendChild(refTag);
  }

  removeReference(event) {
    const btn = event.target;
    const tag = btn.closest("span");
    if (tag) tag.remove();
  }

  // Adiciona uma nova referência a partir dos campos do formulário
  addNewReference(event) {
    event.preventDefault();
    
    // Limpa mensagens de erro anteriores
    if (this.hasErrorMessagesTarget) {
      this.errorMessagesTarget.classList.add('hidden');
      this.errorMessagesTarget.innerHTML = '';
    }
    
    // Busca o wrapper do formulário de nova referência
    const formWrapper = event.target.closest('.border.rounded.p-3.bg-stone-50');
    if (!formWrapper) return;
    const fields = formWrapper.querySelectorAll('input[name^="new_bibliographic_reference["]');
    const newRef = {};
    fields.forEach(input => {
      const key = input.name.match(/new_bibliographic_reference\[(.*)\]/)[1];
      if (key !== 'author_refs_search' && !key.startsWith('author_names')) {
        newRef[key] = input.value.trim();
      }
    });
    // Coleta os IDs dos autores selecionados (AuthorRef)
    const authorIds = Array.from(formWrapper.querySelectorAll('input[name="new_bibliographic_reference[author_ref_ids][]"]')).map(i => i.value);
    if (authorIds.length > 0) {
      newRef.author_ref_ids = authorIds;
    }
    
    // Coleta os nomes dos autores vindos da busca por DOI
    const authorNames = Array.from(formWrapper.querySelectorAll('input[name="new_bibliographic_reference[author_names][]"]')).map(i => i.value);
    if (authorNames.length > 0) {
      newRef.author_names = authorNames;
    }
    // Validação simples
    if (!newRef.title) {
      alert('Título é obrigatório para cadastrar uma nova referência.');
      return;
    }
    
    // Verifica se já existe uma referência com o mesmo título
    this.checkExistingReference(newRef.title)
      .then(exists => {
        if (exists) {
          if (confirm('Já existe uma referência bibliográfica com este título. Deseja utilizá-la ao invés de criar uma nova?')) {
            // Busca a referência existente e a adiciona
            fetch(`/bibliographic_references.json?query=${encodeURIComponent(newRef.title)}&exact=true`)
              .then(r => r.json())
              .then(data => {
                if (data && data.length > 0) {
                  this.addReference(data[0]);
                  // Limpa os campos do formulário
                  fields.forEach(input => input.value = '');
                  // Limpa os autores
                  formWrapper.querySelectorAll('span[data-authors-target="authorTag"]').forEach(tag => tag.remove());
                  // Limpa os autores da busca por DOI
                  const authorsContainer = formWrapper.querySelector('[data-doi-lookup-target="authorsContainer"]');
                  if (authorsContainer) {
                    authorsContainer.innerHTML = '';
                  }
                }
              });
          }
          return Promise.reject('Referência duplicada');
        }
        
        // Se não existe, continua com a criação
        return fetch('/bibliographic_references', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
          },
          body: JSON.stringify({ bibliographic_reference: newRef })
        });
      })
      .then(r => {
        if (!r) return null;  // Se for rejected por ser duplicado
        return r.json();
      })
      .then(data => {
        if (!data) return;  // Se for rejected por ser duplicado
        
        if (data && data.id) {
          this.addReference(data);
          // Limpa os campos do formulário
          fields.forEach(input => input.value = '');
          // Limpa os autores
          formWrapper.querySelectorAll('span[data-authors-target="authorTag"]').forEach(tag => tag.remove());
          // Limpa os autores da busca por DOI
          const authorsContainer = formWrapper.querySelector('[data-doi-lookup-target="authorsContainer"]');
          if (authorsContainer) {
            authorsContainer.innerHTML = '';
          }
        } else if (data.errors) {
          // Exibe erros no formulário
          this.showFormErrors(data.errors);
        } else {
          alert('Erro ao cadastrar referência.');
        }
      })
      .catch(error => {
        if (error !== 'Referência duplicada') {
          alert('Erro ao cadastrar referência.');
          console.error(error);
        }
      });
  }
  
  // Método para verificar se já existe uma referência com o mesmo título
  checkExistingReference(title) {
    return fetch(`/bibliographic_references.json?query=${encodeURIComponent(title)}&exact=true`)
      .then(response => response.json())
      .then(data => {
        // Verifica se alguma referência tem exatamente o mesmo título
        return data.some(ref => ref.title.toLowerCase() === title.toLowerCase());
      })
      .catch(() => false); // Em caso de erro, assume que não existe
  }
  
  // Método para exibir erros no formulário
  showFormErrors(errors) {
    if (this.hasErrorMessagesTarget) {
      const errorContainer = this.errorMessagesTarget;
      
      // Limpa mensagens anteriores
      errorContainer.innerHTML = '';
      
      // Constrói o HTML de erros
      let errorHtml = '<ul class="list-disc ml-6">';
      
      // Para cada campo com erro
      Object.keys(errors).forEach(field => {
        const fieldErrors = errors[field];
        if (Array.isArray(fieldErrors)) {
          fieldErrors.forEach(error => {
            errorHtml += `<li>${field.charAt(0).toUpperCase() + field.slice(1)} ${error}</li>`;
          });
        }
      });
      
      errorHtml += '</ul>';
      
      // Adiciona o HTML ao container e mostra
      errorContainer.innerHTML = errorHtml;
      errorContainer.classList.remove('hidden');
      
      // Esconde após 5 segundos
      setTimeout(() => {
        errorContainer.classList.add('hidden');
      }, 5000);
    } else {
      // Fallback para alert se não tiver o target
      let errorMessage = 'Erros ao cadastrar referência:';
      Object.keys(errors).forEach(field => {
        const fieldErrors = errors[field];
        if (Array.isArray(fieldErrors)) {
          errorMessage += `\n- ${field}: ${fieldErrors.join(', ')}`;
        }
      });
      alert(errorMessage);
    }
  }
}
